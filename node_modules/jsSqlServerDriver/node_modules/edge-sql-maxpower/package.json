{
  "name": "edge-sql-maxpower",
  "author": {
    "name": "Gaetano Lazzo",
    "url": "https://github.com/gaelazzo"
  },
  "version": "0.1.1-pre",
  "description": "Edge-sql: access SQL databases from Node.js using Edge.js and ADO.NET",
  "tags": [
    "edge",
    "net",
    "clr",
    "c#",
    "managed",
    ".net",
    "ado.net"
  ],
  "main": "./lib/edge-sql.js",
  "engines": {
    "node": ">= 0.6"
  },
  "licenses": [
    {
      "type": "Apache",
      "url": "http://www.apache.org/licenses/LICENSE-2.0"
    }
  ],
  "dependencies": {},
  "homepage": "http://gaelazzo/edge-sql",
  "repository": {
    "type": "git",
    "url": "git+ssh://git@github.com/gaelazzo/edge-sql.git"
  },
  "bugs": {
    "url": "http://github.com/gaelazzo/edge-sql/issues"
  },
  "gitHead": "5e52bdbff6cd34fd067b85b568e954c6a1787abf",
  "readme": "edge-sql-maxpower\r\n=======\r\n\r\nThis is a SQL compiler for edge.js branched from [edge-sql](https://github.com/tjanczuk/edge-sql \"edge-sql\"). It allows accessing databases from Node.js using [Edge.js](https://github.com/tjanczuk/edge \"Edge.js\") through ADO.NET \r\n\r\nThis contains some major improvements  as:\r\n#### \r\n* support for DateTime values\r\n* support for **transaction** having the ability to open and close a connection keeping it open in the while\r\n* support for null values \r\n* **packet-ized** output option ouput is in the form {meta:[column names], rows:[[array of values]]} when packet size=0, otherwise meta and rows are given separately, with packets of max 'packet size' rows of data \r\n* support for Decimal values\r\n* support for **any kind of command** (as Ryan says 'just do it'), via a cmd parameter. If it is 'nonquery', a (.net) *ExecuteNonQuery* is runned, otherwise a (.net) *ExecuteReaderAsync* \r\n* support for **multiple result set**: they are returned as [ {meta:[column names], rows:[[..]]}, {meta:[column names], rows:[[..]]}, ....}\r\n* support for smallint (Int16) values\r\n* it is possible to give **connectionString** as parameter\r\n* it is possible to give a **connection handler** as parameter \r\n* additional commands provided through cmd parameter are:  open, close, nonquery. \"nonquery\" commands are useful for updating db, where the sql **result is the number of rows affected**. This value is returned in \"**rowcount**\" output field.\r\n\r\n**\r\n####\r\n\r\nFor any other information: read the code :)\r\n\r\nIn all the examples, a JQuery Deferred is used.\r\n\r\n# How to #\r\n## open a connection ##\r\n   \r\n    function edgeOpen(adoString) {\r\n      var def =  Deferred(),\t\r\n    \tedgeOpenInternal = edge.func('sql-maxpower',\r\n    \t  { source: 'open', \r\n    \t\tconnectionString: adoString,\r\n    \t\tcmd: 'open'\r\n      \t});\r\n      edgeOpenInternal({}, \r\n    \tfunction (error, result) {\r\n    \t\tvar i;\r\n    \t\tif (error) {\r\n      \t\t\tdef.reject(error);\r\n      \t\t\treturn;\r\n    \t\t}\r\n    \t\tif (result) {      \t\t\r\n\t\t\t\t//result is a handler to a sql connection\t\r\n      \t\t\tdef.resolve(that);  \r\n      \t\t\treturn;\r\n    \t\t}\r\n    \t\tdef.reject('shouldnt reach here');\r\n      \t});\r\n      return def.promise();\r\n    };\r\n\r\n\r\n## close a connection ##\r\n    function edgeClose(handler) {\r\n      var def =  Deferred(),\r\n    \tedgeCloseInternal = edge.func('sql-maxpower',\r\n      \t\t{ handler: handler,\r\n    \t\t\tsource:'close',\r\n    \t\t\tcmd: 'close'\r\n      \t\t});\r\n      \tedgeCloseInternal({}, function (error, result) {\r\n    \t\tif (error) {\r\n      \t\t\tdef.reject(error);\r\n      \t\t\treturn;\r\n    \t\t}   \r\n    \t\tdef.resolve(null);\r\n      \t});\r\n      return def.promise();\r\n    };\r\n    \r\n## Execute a generic sql command ##\r\n\r\n    /**\r\n     * Executes a sql command and returns all sets of results. Each Results is given via a notify or resolve\r\n     * @method queryBatch\r\n     * @param {string} query\r\n     * @param {boolean} [raw] if true, data are left in raw state and will be objectified by the client\r\n     * @param handler handler for the connection or connection string\r\n     * @returns {*}  a sequence of {[array of plain objects]} or {meta:[column names],rows:[arrays of raw data]}\r\n     */\r\n    function queryBatch(query, raw, handler) {\r\n      var edgeQuery = edge.func(\r\n    \t'sql-maxpower', \r\n    \t_.extend({source: query},handler)),\r\n    \tdef =  Deferred();\r\n      \tedgeQuery({}, function (error, result) {\r\n    \tif (error) {\r\n      \t\tdef.reject(error);\r\n      \t\treturn;\r\n    \t}\r\n    \tvar i;\r\n    \tfor (i=0; i< result.length-1; i++){\r\n      \t\tif (raw){\r\n    \t\tdef.notify(result[i]);\r\n    \t\t} else {\r\n    \t\tdef.notify(simpleObjectify(result[i].meta, result[i].rows));\r\n      \t\t}\r\n    \t}\r\n    \tif (raw) {\r\n      \t\tdef.resolve(result[i]);\r\n    \t} else {\r\n      \t\tdef.resolve(simpleObjectify(result[i].meta, result[i].rows));\r\n    \t}\r\n      \t});\r\n      \treturn def.promise();\r\n    };\r\n    \r\nThis example uses a function, simpleObjectify, to transform raw-data coming from sql-server into plain objects:\r\n\r\n    /**\r\n     * simplified objectifier having an array of column names for first argument\r\n     * @private\r\n     * @param {Array} colNames\r\n     * @param {Array} rows\r\n     * @returns {Array}\r\n     */\r\n    function simpleObjectify(colNames, rows) {\r\n      var colLength = colNames.length,\r\n      \trowLength = rows.length,\r\n    \tresult = [],\r\n    \trowIndex = rowLength,\r\n    \tcolIndex,\r\n    \tvalue,\r\n    \trow;\r\n      \twhile( --rowIndex >=0){\r\n    \t\tvalue={};\r\n    \t\trow = rows[rowIndex];\r\n    \t\tcolIndex = colLength;\r\n    \t\twhile(--colIndex >=0){\r\n      \t\t\tvalue[colNames[colIndex]]= row[colIndex];\r\n    \t\t}\r\n    \t\tresult[rowIndex] = value;\r\n      \t}\r\n      \treturn result;\r\n    }\r\n\r\n\r\n## Execute a batch of sql commands ##\r\n    /**\r\n     * Executes a series of sql update/insert/delete commands\r\n     * @method updateBatch\r\n     * @param query batch of sql commands to execute\r\n     * @param handler handler for the connection or connection string\r\n     * @returns {*}\r\n     */\r\n    function updateBatch(query,handler) {\r\n      var edgeQuery = edge.func('sql-maxpower', \r\n\t\t\t_.extend({source: query, cmd:'nonquery'},\r\n      \t\thandler)),\r\n    def =  Deferred();\r\n      edgeQuery({}, function (error, result) {\r\n    \tif (error) {\r\n      \t\tdef.reject(error);\r\n      \t\treturn;\r\n    \t}\r\n    \tdef.resolve(result);\r\n      });\r\n      return def.promise();\r\n    };\r\n\r\n## Get n rows at a time from a query ##\r\n\r\n    \r\n    /**\r\n     * Gets data packets row at a time\r\n     * @method queryPackets\r\n     * @param {string} query\r\n     * @param {boolean} [raw=false]\r\n     * @param {number} [packSize=0]\r\n     * @param handler handler for the connection or connection string\r\n     * @returns {*}\r\n     */\r\n    function queryPackets(query, raw, packSize, handler) {\r\n      var def =  Deferred(),\r\n    \tpacketSize = packSize || 0,\r\n    \tlastMeta,\r\n    \tcurrentSet = -1,\r\n    \ttable,\r\n    \tcallback = function (data, resCallBack) {\r\n      \t\tif (data.meta){\r\n    \t\t\tcurrentSet += 1;\r\n      \t\t}\r\n      \t\tdata.set = currentSet;\r\n      \t\tif (raw) {\r\n    \t\t\tdef.notify(data);\r\n      \t\t} else {\r\n    \t\t\tif (data.meta) {\r\n      \t\t\t\tlastMeta = data.meta;\r\n    \t\t\t} else {\r\n      \t\t\t\tdef.notify({rows: simpleObjectify(lastMeta, data.rows),\r\n\t\t\t\t\t\t\tset: currentSet});\r\n    \t\t\t}\r\n      \t\t}\r\n    \t},\r\n    edgeQuery = edge.func('sql-maxpower', \r\n\t\t_.extend({source: query, callback: callback, packetSize: packetSize},\r\n      \t\thandler));\r\n      edgeQuery({}, function (error, result) {\r\n    \t\tvar i;\r\n    \t\tif (error) {\r\n      \t\t\tdef.reject(error);\r\n      \t\t\treturn;\r\n    \t\t}\r\n       \t\tdef.resolve();\r\n      });\r\n      return def.promise();\r\n    };\r\n    \r\nfor example you can use simply use this function as\r\n\r\n    queryPackets('select * from orders', false, 0, connectionString)\r\n    .done(function(result){\r\n    })\r\n    .fail(function(err){\r\n    });\r\n\r\n\r\n## Get N rows one at a time ##\r\n    /**\r\n     * Gets a table and returns each SINGLE row by notification. Could eventually return more than a table indeed\r\n     * For each table read emits a {meta:[column descriptors]} notification, and for each row of data emits a\r\n     *   if raw= false: {row:object read from db}\r\n     *   if raw= true: {row: [array of values read from db]}\r\n    \r\n     * @method queryLines\r\n     * @param {string} query\r\n     * @param {boolean} [raw=false]\r\n     * @param handler handler for the connection or connection string\r\n     * @returns {*}\r\n     */\r\n    function queryLines(query, raw, handler) {\r\n      var def =  Deferred(),\r\n    \tlastMeta,\r\n    \tobjMaker,\r\n    \tcallback = function(data, resCallBack) {\r\n      \t\tif (data.rows) {\r\n    \t\t\tif (raw) {\r\n      \t\t\t\tdef.notify({row: data.rows[0]});\r\n    \t\t\t} else {\r\n      \t\t\t\tdef.notify({row: simpleObjectifier(lastMeta,data.rows[0])});\r\n    \t\t\t}\r\n     \t } else {\r\n    \t\tlastMeta = data.meta;\r\n    \t\tdef.notify(data);\r\n     \t }\r\n    \t},\r\n       edgeQuery = edge.func('sql-maxpower',\r\n    \t _.extend({source: query,callback: callback,packetSize: 1},\r\n    \thandler));\r\n    \tedgeQuery({}, function (error, result) {\r\n      \t\tvar i;\r\n      \t\tif (error) {\r\n    \t\t\tdef.reject(error);\r\n    \t\t\treturn;\r\n      \t\t}\r\n      \t\tif (result.length === 0) {\r\n    \t\t\tdef.resolve();\r\n    \t\t\treturn;\r\n      \t\t}\r\n      \t\tdef.reject('shouldnt reach here');\r\n    \t});\r\n      \treturn def.promise();\r\n    \t};\r\n    ",
  "readmeFilename": "README.md",
  "_id": "edge-sql-maxpower@0.1.1-pre",
  "_shasum": "a39222c78c2aac271b90ee23a088ff046a0ed475",
  "_from": "git://github.com/gaelazzo/edge-sql.git",
  "_resolved": "git://github.com/gaelazzo/edge-sql.git#5e52bdbff6cd34fd067b85b568e954c6a1787abf"
}
