{
  "name": "jsDataQuery",
  "version": "1.0.1",
  "description": "Query functions convertable into sql expressions",
  "main": "src/jsDataQuery.js",
  "scripts": {
    "test": "grunt test"
  },
  "dependencies": {
    "lodash": "~3.1.0"
  },
  "devDependencies": {
    "grunt": "~0.4.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-contrib-yuidoc": "^0.7.0",
    "grunt-karma": "^0.10.1",
    "jasmine-core": "^2.2.0",
    "jasmine-collection-matchers": "*",
    "karma": "^0.12.31",
    "karma-jasmine": "^0.3.5",
    "karma-junit-reporter": "^0.2.2",
    "karma-phantomjs-launcher": "^0.1.4",
    "karma-sauce-launcher": "^0.2.10",
    "load-grunt-tasks": "^3.1.0",
    "time-grunt": "^1.0.0"
  },
  "repository": {
    "type": "git",
    "url": "git+https://github.com/gaelazzo/jsDataQuery.git"
  },
  "keywords": [
    "query",
    "expression",
    "javascript",
    "sql",
    "compiler"
  ],
  "author": {
    "name": "Gaetano Lazzo"
  },
  "license": "ISC",
  "bugs": {
    "url": "https://github.com/gaelazzo/jsDataQuery/issues"
  },
  "homepage": "https://github.com/gaelazzo/jsDataQuery#readme",
  "gitHead": "e7f582032cdef76377051d3ba36dad2d4eec396e",
  "readme": "# jsDataQuery\r\nQuery functions convertable into sql expressions\r\n\r\njsDataQuery allow building sql expression {*sqlFun*} that can be applied to javascript objects. Then it is possible to convert that expression into a sql-readable string, simply invoking the toSql method of the object.\r\n\r\n**toSql** method is not specific to a single database provider, infact it must be supplied from the external.\r\nSo it's possible to query any kind of database with the same {*sqlFun*}, provided that when the function will be applied to a specific database, the formatter for it will be provided.\r\nSo you don't have to care of specific sql-dialect when building  query. More, the same query will be also appliable to javascript objects.\r\n\r\nFor example,\r\n\r\n    it('comparing values through field not equal', function () {\r\n      var \tx = {a: 1, b: 2, c: 3},\r\n    \t\tf = $q.eq($q.field('a'), 2);\r\n      expect(f(x)).toBeFalsy();\r\n      x.a=2;\r\n      expect(f(x)).toBeTruthy();\r\n    });\r\n    \r\n\r\nsqlFun are also higly optimized so that if the engine detects they are simplifiable, they will be treathed as constant and not submitted in their original form:\r\n\r\n    it('and of false function with other function should be the always false function', \tfunction(){\r\n      \t\tvar xx = {a: 'AABBCC', q: '1'},\r\n    \t\t\tcond1 = $q.like('a', 'AAB_CC'),\r\n    \t\t\tcond2 = $q.eq('q', 1),\r\n    \t\t\tcond3 = $q.constant(false),\r\n    \t\tf = $q.and(cond1, cond2, cond3);\r\n      \t\texpect(f.isFalse).toBe(true);\r\n    \t});\r\nNotice that f.isFalse is a property of the function, not the result of applying the function to a particolar argument. The engine has detected that f is a constant function.    \r\n\r\nIf some parts of an expression are undefined, the expression may still be successfull evalued:\r\n\r\n     it('and of a series of function including one undefined and one dinamically-false gives false', function () {\r\n      \tvar xx = {a: 'AABBCC', q: '1'},\r\n    \t\tf = $q.and($q.like('a', 'AAB_CC'), $q.eq('q', 2), undefined);\r\n      \t\texpect(f(xx)).toBe(false);\r\n    });\r\n\r\nIn this case f(xx) is false because xx['q']!== 2 so and-ing the value qith the the other function will be false, no matter if some of them are undefined.\r\n\r\nFor easy of using, many operator are \"auto-fielded\" in the first operand.\r\nFor example, normally if you write\r\n\r\n`$q.eq('a',2)` \r\n\r\nit would mean \"give me the function that compares the character constant 'a' whith 2\".\r\nBut the first operand is \"auto-fielded\" so it is normally assumed, when it is a character constant, to be the name of an identifier. So it is interpreted as:\r\n\"give me the function that compares the field named 'a' with 2\"\r\nI.E. it is threated as the equivalent of\r\n\r\n`$q.eq($q.field('a'),2)`\r\n\r\n  \r\nwhere $q.field(x) is the function that applied to an object will return the field of that object named x:\r\n\r\n     it('comparing values through field equal', function () {\r\n      var \tx = {a: 1, b: 2, c: 3},\r\n    \t\tf = $q.eq($q.field('a'), 1);\r\n\t\t\tg = $q.eq('a', 1);\r\n      \texpect(f(x)).toBeTruthy();\r\n      \texpect(g(x)).toBeTruthy();\r\n      \tx.a=2;\r\n      \texpect(f(x)).toBeFalsy();\r\n      \texpect(g(x)).toBeFalsy();\r\n    });\r\n\r\nHere f and g are the function that compares the field named 'a' of the argument with the constant 1.\r\n     ",
  "readmeFilename": "README.MD",
  "_id": "jsDataQuery@1.0.1",
  "_shasum": "aedb08ab7c50a12b413ab74e01b032129a79147c",
  "_from": "git+https://github.com/gaelazzo/jsDataQuery.git",
  "_resolved": "git+https://github.com/gaelazzo/jsDataQuery.git#e7f582032cdef76377051d3ba36dad2d4eec396e"
}
